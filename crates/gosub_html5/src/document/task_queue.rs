use crate::DocumentHandle;
use gosub_shared::traits::document::Document;
use std::collections::HashMap;

use crate::parser::tree_builder::TreeBuilder;
use gosub_shared::byte_stream::Location;
use gosub_shared::node::NodeId;
use gosub_shared::traits::css3::CssSystem;
use gosub_shared::traits::node::{ElementDataType, Node};
use gosub_shared::types::Result;

/// Enum of tasks that can be performed to add or
/// update nodes in the tree.
///
/// These tasks are generated by a TreeBuilder which is implemented
/// by DocumentTaskQueue which holds a handle to the actual Document
/// to commit changes to.
pub enum DocumentTask {
    CreateElement {
        name: String,
        namespace: String,
        parent_id: NodeId,
        position: Option<usize>,
        location: Location,
    },
    CreateText {
        content: String,
        parent_id: NodeId,
        location: Location,
    },
    CreateComment {
        content: String,
        parent_id: NodeId,
        location: Location,
    },
    InsertAttribute {
        key: String,
        value: String,
        element_id: NodeId,
        location: Location,
    },
}

/// Queue of tasks that will mutate the document to add/update
/// nodes in the tree. These tasks are performed sequentially in the
/// order they are created.
///
/// Once tasks are queued up, a call to flush() will commit all changes
/// to the DOM. If there are errors during the application of these changes,
/// flush() will return a list of the errors encountered but execution is not halted.
///
/// create_element() will generate and return a new NodeId for the parser to keep
/// track of the current context node and optionally store this in a list of open elements.
/// When encountering a closing tag, the parser must pop this ID off of its list.
pub struct DocumentTaskQueue<D: Document<C>, C: CssSystem> {
    /// Internal counter of the next ID to generate from the NodeArena
    /// without actually registering the node.
    /// WARNING: if nodes are registered in the arena while tasks are being queued
    /// this could lead to conflicts in NodeIds. NodeArena should NOT be used directly
    /// if using a DocumentTaskQueue.
    #[allow(dead_code)]
    next_node_id: NodeId,
    /// Reference to the document to commit changes to
    pub(crate) doc_handle: DocumentHandle<D, C>,
    /// List of tasks to commit upon flush() which is cleared after execution finishes.
    // IMPLEMENTATION NOTE: using a vec here since I'm assuming we are
    // executing all tasks at once. If we need to support stopping task
    // execution midway, then maybe a real "queue" structure that pops
    // completed tasks is needed.
    pub(crate) tasks: Vec<DocumentTask>,
}

impl<D: Document<C>, C: CssSystem> DocumentTaskQueue<D, C> {
    pub fn is_empty(&self) -> bool {
        self.tasks.is_empty()
    }

    pub fn flush(&mut self) -> Vec<String> {
        let mut errors = Vec::new();

        for current_task in &self.tasks {
            match current_task {
                DocumentTask::CreateElement {
                    name,
                    namespace,
                    parent_id,
                    position,
                    location,
                } => {
                    let node = D::new_element_node(
                        self.doc_handle.clone(),
                        name,
                        Some(namespace),
                        HashMap::new(),
                        *location,
                    );
                    self.doc_handle.get_mut().register_node_at(node, *parent_id, *position);
                }
                DocumentTask::CreateText {
                    content,
                    parent_id,
                    location,
                } => {
                    let node = D::new_text_node(self.doc_handle.clone(), content, *location);
                    self.doc_handle.get_mut().register_node_at(node, *parent_id, None);
                }
                DocumentTask::CreateComment {
                    content,
                    parent_id,
                    location,
                } => {
                    let node = D::new_comment_node(self.doc_handle.clone(), content, *location);
                    self.doc_handle.get_mut().register_node_at(node, *parent_id, None);
                }
                DocumentTask::InsertAttribute {
                    key, value, element_id, ..
                } => {
                    // Invalid ID value?
                    if key == "id" && !is_valid_id_attribute_value(value) {
                        errors.push(format!("ID attribute value '{value}' did not pass validation"));
                        continue;
                    }

                    // An ID must be tied to only one element
                    let binding = self.doc_handle.get();
                    let named_node = binding.node_by_named_id(value);
                    if named_node.is_some() && named_node.unwrap().id() != *element_id {
                        errors.push(format!("ID attribute value '{value}' already exists in DOM"));
                        continue;
                    }
                    drop(binding);

                    let mut binding = self.doc_handle.get_mut();
                    let Some(node) = binding.node_by_id(*element_id) else {
                        errors.push(format!("Node id {} not found", element_id));
                        continue;
                    };

                    if !node.is_element_node() {
                        errors.push(format!("Node id {} is not an element", element_id));
                        continue;
                    }

                    let mut node = node.clone();

                    let element_data = node.get_element_data_mut().unwrap();
                    element_data.add_attribute(key, value);

                    binding.update_node(node);
                }
            }
        }
        self.tasks.clear();

        errors
    }
}

/// according to HTML spec: https://html.spec.whatwg.org/#global-attributes
pub(crate) fn is_valid_id_attribute_value(value: &str) -> bool {
    !(value.is_empty() || value.contains(|ref c| char::is_ascii_whitespace(c)))
}

// See tree_builder.rs for method comments
impl<D: Document<C>, C: CssSystem> TreeBuilder for DocumentTaskQueue<D, C> {
    fn create_element(
        &mut self,
        name: &str,
        parent_id: NodeId,
        position: Option<usize>,
        namespace: &str,
        location: Location,
    ) -> NodeId {
        let element = DocumentTask::CreateElement {
            name: name.to_owned(),
            parent_id,
            position,
            namespace: namespace.to_owned(),
            location,
        };
        let new_id = self.next_node_id;
        self.next_node_id = self.next_node_id.next();
        self.tasks.push(element);

        new_id
    }

    fn create_text(&mut self, content: &str, parent_id: NodeId, location: Location) -> NodeId {
        let text = DocumentTask::CreateText {
            content: content.to_owned(),
            parent_id,
            location,
        };
        let new_id = self.next_node_id;
        self.next_node_id = self.next_node_id.next();
        self.tasks.push(text);

        new_id
    }

    fn create_comment(&mut self, content: &str, parent_id: NodeId, location: Location) -> NodeId {
        let comment = DocumentTask::CreateComment {
            content: content.to_owned(),
            parent_id,
            location,
        };
        let new_id = self.next_node_id;
        self.next_node_id = self.next_node_id.next();
        self.tasks.push(comment);

        new_id
    }

    fn insert_attribute(&mut self, key: &str, value: &str, element_id: NodeId, location: Location) -> Result<()> {
        let attribute = DocumentTask::InsertAttribute {
            key: key.to_owned(),
            value: value.to_owned(),
            element_id,
            location,
        };
        self.tasks.push(attribute);
        Ok(())
    }
}

impl<D: Document<C>, C: CssSystem> DocumentTaskQueue<D, C> {
    pub fn new(doc_handle: DocumentHandle<D, C>) -> Self {
        let next_node_id = doc_handle.get().peek_next_id();
        Self {
            next_node_id,
            doc_handle: doc_handle.clone(),
            tasks: Vec::new(),
        }
    }
}
